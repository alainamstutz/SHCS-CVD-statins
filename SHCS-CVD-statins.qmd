---
title: "NUDGE cluster randomized trial"
author: "B. Surial, A. Boyd, A.Amstutz"
format:
  html:
    toc: true
    toc-float: true
    toc-depth: 4
    code-fold: true
    keep-md: true
  pdf:
    toc: true
editor: visual
---

# NUDGE SHCS precision CVD/statin CRT

Nudging intervention on the level of SHCS physicians at SHCS sites to promote statin prescription:

-   **Control**: Usual Care

-   **Intervention**: Nudge shared-decision making based on improved CVD risk score

## **Parameters and design considerations**

-   Two-arm parallel-group, 1:1 allocation, superiority, cluster-randomized

-   Cluster eligibility:

    -   SHCS physicians who use Django

    -   Saw at least 5 elig pat in the previous year

    -   Are not planning to move out of the site within coming 6m

-   Individual eligibility:

    -   Age ≥40 years and ≤75 years
    -   Receiving antiretroviral therapy
    -   Currently not receiving a statin
    -   No documented intolerance, allergy, or adverse reaction towards statins
    -   Not pregnant or breastfeeding
    -   For primary analysis population (powered): No prior CVD or diabetes

-   Primary outcome (binary): “being prescribed a statin within 6m after first patient-encounter”

-   Unit of data collection with be the SHCS cohort participants, but level of inference will be the physicians, i.e. cluster-average

-   Baseline primary outcome rate, see calculation below:

    -   Overall: 22%
    -   Women: 15%
    -   Men: 25%

-   Expected delta:

    -   Overall: 10-15 pp (based on JAMA + a bit more to be expected due to difference in providers & nudge)
    -   Slightly better effect among women than men (but probably not more than 5pp)

-   Cluster size (m) of eligible participants, see calculation below:

    -   Overall: 34 eligible participants per physician-cluster
    -   Women: 14 eligible participants per physician-cluster

-   CV (coefficient of variation), see calculation below:

    -   Overall: 0.95
    -   Women: 0.73

-   ICC for the primary outcome, see calculation below:

    -   Overall: 0.07 (take conservative 0.10)
    -   Women: 0.03 (take conservative 0.05)

-   Max. ca. 170 eligible clusters

-   Min. desired power 80%, two-sided alpha of 0.05

**Packages & seed**

```{r}
#| message: false
#| warning: false
req_pkgs <- c("pwr",
              "dplyr",
              "tidyr",
              "purrr",
              "ggplot2",
              "here",
              "lme4",
              "performance",
              "gt"
)
install_if_missing <- function(pkgs){
  for(p in pkgs){
    if(!requireNamespace(p, quietly=TRUE)){
      install.packages(p, repos="https://cloud.r-project.org")
    }
    library(p, character.only=TRUE)
  }
}
install_if_missing(req_pkgs)

# set global RNG seed for reproducibility
set.seed(20250809)
```

**Prep Data SHCS**

```{r}
#| message: false
#| warning: false
df_ev <- readRDS(here("01-eligible_visits25.rds"))
df_vpp <- readRDS(here("01-visits_per_physician25.rds"))

# Remove any existing grouping
df_ev <- df_ev |> 
  ungroup()
df_vpp <- df_vpp |> 
  ungroup()

# Get data by physician and SEX
df_vpp_sex <- df_ev |> 
  # Get to distinct participant-id pairs
  # NOTE: individuals who had a visit without and one with statin will be 
  # counted as two separate individuals
  distinct(id, physician, center, source, on_statin, sex) |> 
  group_by(physician, sex) |> 
  # Get the number of peoplel overal, and the number of people not on statin
  summarise(n_overall = n(),
            n_without_statin = sum(!on_statin), 
            statin_presc_rate = 1 - n_without_statin/n_overall) |> 
  ungroup()

# Proportion of eligible women across all clusters
sex_ratio_df <- df_vpp_sex %>%
  group_by(physician) %>%
  summarise(
    male_count = n_without_statin[sex == 1],
    female_count = n_without_statin[sex == 2],
    total_patients = sum(n_without_statin),
    pct_female = (female_count / total_patients) * 100
  )

# Mean eligible pct_female across all clusters
mean_pct_female <- mean(sex_ratio_df$pct_female)
print(paste("Mean percentage of eligible female across all physician clusters:", 
            round(mean_pct_female, 2), "%"))

# Sex-specific df
df_vpp_women <- df_vpp_sex |>
  filter(sex == 2)
df_vpp_men <- df_vpp_sex |>
  filter(sex == 1)
```

## **Calculation CV**

```{r}
# # Keep only physicians who have at least seen 5 pat in past year
df_vpp <- df_vpp |>
  filter(n_without_statin >= 5)
df_vpp_women <- df_vpp_women |>
  filter(n_without_statin >= 5)
df_vpp_men <- df_vpp_men |>
  filter(n_without_statin >= 5)

# Calculate CV for cluster sizes (=physicians)
# CV = sd(n_without_statin) / mean(n_without_statin)
cv_tbl <- df_vpp |>
  summarise(
    n_clusters = n(),
    mean_cluster_size = mean(n_without_statin),
    sd_cluster_size = sd(n_without_statin),
    cv = sd_cluster_size / mean_cluster_size
  )

cv_tbl |>
  gt() |>
  cols_label(
    n_clusters = "Number of Clusters",
    mean_cluster_size = "Mean Cluster Size",
    sd_cluster_size = "SD Cluster Size",
    cv = "CV"
  ) |>
  fmt_number(
    columns = c(mean_cluster_size, sd_cluster_size, cv),
    decimals = 2
  ) |>
  tab_header(
    title = "Coefficient of Variation ALL participants"
  ) |>
  tab_options(
    table.font.size = 14
  )

cv_tbl_women <- df_vpp_women |>
  summarise(
    n_clusters = n(),
    mean_cluster_size = mean(n_without_statin),
    sd_cluster_size = sd(n_without_statin),
    cv = sd_cluster_size / mean_cluster_size
  )

cv_tbl_women |>
  gt() |>
  cols_label(
    n_clusters = "Number of Clusters",
    mean_cluster_size = "Mean Cluster Size",
    sd_cluster_size = "SD Cluster Size",
    cv = "CV"
  ) |>
  fmt_number(
    columns = c(mean_cluster_size, sd_cluster_size, cv),
    decimals = 2
  ) |>
  tab_header(
    title = "Coefficient of Variation Women"
  ) |>
  tab_options(
    table.font.size = 14
  )
```

## **Calculation baseline rate and ICC**

```{r}
# Calculate number of eligible patients who received statins
df_vpp <- df_vpp |>
  mutate(n_with_statin = n_overall - n_without_statin)
df_vpp_women <- df_vpp_women |>
  mutate(n_with_statin = n_overall - n_without_statin)
df_vpp_men <- df_vpp_men |>
  mutate(n_with_statin = n_overall - n_without_statin)

# Reconstruct individual patient data (only eligible patients)
individual_data <- df_vpp |>
  rowwise() |>
  mutate(
    patient_data = list(
      tibble(
        statin_prescribed = c(
          rep(1, n_with_statin),
          rep(0, n_without_statin)
        )
      )
    )
  ) |>
  ungroup() |>
  unnest(patient_data) |>
  select(center, physician, statin_prescribed)

# Verify
ind_data <- individual_data |>
  group_by(physician) |>
  summarise(
    n_total = n(),
    n_received_statin = sum(statin_prescribed),
    rate = mean(statin_prescribed)
  )

individual_data_women <- df_vpp_women |>
  rowwise() |>
  mutate(
    patient_data = list(
      tibble(
        statin_prescribed = c(
          rep(1, n_with_statin),
          rep(0, n_without_statin)
        )
      )
    )
  ) |>
  ungroup() |>
  unnest(patient_data) |>
  select(physician, statin_prescribed)

individual_data_men <- df_vpp_men |>
  rowwise() |>
  mutate(
    patient_data = list(
      tibble(
        statin_prescribed = c(
          rep(1, n_with_statin),
          rep(0, n_without_statin)
        )
      )
    )
  ) |>
  ungroup() |>
  unnest(patient_data) |>
  select(physician, statin_prescribed)

# baseline rate
baseline_rate <- individual_data |>
  summarise(
    baseline_rate = mean(statin_prescribed)
  )

baseline_rate

baseline_rate_women <- individual_data_women |>
  summarise(
    baseline_rate_women = mean(statin_prescribed)
  )

baseline_rate_women

baseline_rate_men <- individual_data_men |>
  summarise(
    baseline_rate_men = mean(statin_prescribed)
  )

baseline_rate_men

# Calculate ICC
model <- glmer(statin_prescribed ~ 1 + (1 | physician), 
               data = individual_data, 
               family = binomial)

icc(model)

model_women <- glmer(statin_prescribed ~ 1 + (1 | physician), 
               data = individual_data_women, 
               family = binomial)

icc(model_women)
```

## **Corresponding individual randomized trial**

Sample size for the individual randomized trial on the same question

```{r}
# Parameters
p_C <- 0.22
p_I <- 0.32
power <- 0.80 
alpha <- 0.05

# Effect size, standardized as Cohen's h
h_I_C <- ES.h(p1 = p_I, p2 = p_C)
cat("Cohen's h for Intervention vs Control:", round(h_I_C, 3), "\n")

# Sample size pair-wise comparison
ss_I_C <- pwr.2p.test(h = h_I_C, sig.level = alpha, power = power)
n_per_arm <- ceiling(ss_I_C$n)
n_total <- n_per_arm * 2

cat("Sample size per arm:", n_per_arm, "\n")
cat("Total trial sample size (2-arm trial):", n_total)
```

# **(1) Sample size calculation CRT: formula-based**

Add the design effect (DEFF) to the individual RCT sample size. The usual standard DEFF formula:

DEFF = 1+(m−1)ICC , whereby m = cluster size

However, let's not forget the cluster size variation. The usual conservative adjustment of the DEFF with cluster size variation is (e.g. see here: [https://pmc.ncbi.nlm.nih.gov/articles/PMC7394950/#sup1](#0)):

DEFF_cv = 1+((m(1+CV\^2)−1))ICC , whereby CV is the coefficient of variation (ratio of standard deviation of cluster sizes to mean of cluster sizes)

## **(1.1) Global sample size**

```{r}
# Parameters
p_C <- 0.22
p_I <- 0.32  
power <- 0.80 
ICC <- 0.10
alpha <- 0.05

m <- 34 # average cluster size
CV <- 0.95 # CV

deff <- 1+(m-1)*ICC # standard DEFF
deff_cv <- 1+((m*(1+CV^2))-1)*ICC # DEFF with cluster size variation

# Effect size
h_I_C <- ES.h(p1 = p_I, p2 = p_C)

# sample size for corresponding individual RCT 
ss <- pwr.2p.test(h = h_I_C, power = power, sig.level = alpha)$n

# CRT sample size
ss_crt <- ceiling(ss * deff_cv)
n_clusters <- ceiling(ss_crt / m)
cat("Cluster sample size one arm:", n_clusters, "\n")
# cat("Individual sample size one arm:", ss_crt, "\n")

# Total
tot_clusters <- n_clusters * 2
tot_ind <- ss_crt * 2
cat("Total cluster sample size:", tot_clusters, "\n")
cat("Total individual sample size:", tot_ind, "\n")
```

## **(1.2) Subgroup sample size**

### **(1.2.1)** First, check if we could power it for a moderate interaction effect

```{r}
# Parameters
power <- 0.80
alpha <- 0.05
ICC <- 0.10
m <- 34
CV <- 0.95

prop_w <- 0.36 # proportion women, see calculation above
prop_m <- 1 - prop_w

# Sex-specific event probabilities (ASSUMPTIONS)
p_C_w <- 0.15 # see calculation above
p_C_m <- 0.25 # see calculation above
p_I_w <- 0.30 # we expect 15 pp among women
p_I_m <- 0.35 # we expect 10 pp among men

# Treatment effects within sex
h_w <- ES.h(p1 = p_I_w, p2 = p_C_w)
h_m <- ES.h(p1 = p_I_m, p2 = p_C_m)

# Interaction effect -> difference in treatment effects
h_int <- abs(h_w - h_m)

# Individual-level power calculation for interaction (per sex per arm)
ss_ind_int <- pwr.2p.test(
  h = h_int,
  power = power,
  sig.level = alpha)$n

# Adjust for unequal sex proportions
# Required individuals per arm (dominated by smaller subgroup)
ss_ind_adj <- max(
  ss_ind_int / prop_w,
  ss_ind_int / prop_m)

# Design effect for cluster randomization, as above
deff_cv <- 1 + ((m * (1 + CV^2)) - 1) * ICC
ss_crt <- ceiling(ss_ind_adj * deff_cv)

# Clusters per arm
n_clusters <- ceiling(ss_crt / m)

cat("Interaction effect (Cohen's h):", round(h_int, 3), "\n")
cat("Individuals per arm (after sex adjustment):", ss_crt, "\n")
cat("Clusters per arm:", n_clusters, "\n")
cat("Total clusters:", 2 * n_clusters, "\n")
cat("Total individuals:", 2 * ss_crt, "\n")
```

### **(1.2.2)** Second, check if we can power it for subgroup women alone

With 90% power.

Cluster size is obviously lower, but also less variability (CV lower, ICC lower)

```{r}
# Parameters
p_C <- 0.15
p_I <- 0.25  
power <- 0.90
alpha <- 0.05
ICC <- 0.05
m <- 14
CV <- 0.95

deff <- 1+(m-1)*ICC # standard DEFF
deff_cv <- 1+((m*(1+CV^2))-1)*ICC # DEFF with cluster size variation

# Effect size
h_I_C <- ES.h(p1 = p_I, p2 = p_C)

# sample size for corresponding individual RCT 
ss <- pwr.2p.test(h = h_I_C, power = power, sig.level = alpha)$n

# CRT sample size
ss_crt <- ceiling(ss * deff_cv)
n_clusters <- ceiling(ss_crt / m)
cat("Cluster sample size one arm, women only:", n_clusters, "\n")
# cat("Individual sample size one arm:", ss_crt, "\n")

# Total
tot_clusters <- n_clusters * 2
tot_ind <- ss_crt * 2
cat("Total cluster sample size, women only:", tot_clusters, "\n")
cat("Total individual sample size, women only:", tot_ind, "\n")
```

## **(1.3) Varying assumptions - Standard sample size calculation**

### **(1.3.1) Varying Effect size and varying ICC - overall population**

3-D plot, varying the effect size (10 pp to 20 pp) & varying ICC (0.05 to 0.2)

Keep the baseline prescription rate at 22% (control rate)

Keep m (cluster size) at 34

Keep the CV at 0.95

```{r}
# Define parameters
power <- 0.80
alpha <- 0.05
p_C <- 0.22
CV <- 0.95
m <- 34

# Ranges
ICC_values <- seq(0.05, 0.20, by = 0.01)
effect_sizes_pp <- seq(10, 20, by = 1)

# Create grid
results_3d <- expand.grid(
  ICC = ICC_values,
  effect_size_pp = effect_sizes_pp
)

results_3d$n_clusters_per_arm <- NA

cohen_h <- function(p1, p2) {
  2 * (asin(sqrt(p1)) - asin(sqrt(p2)))
}

for (i in 1:nrow(results_3d)) {
  icc <- results_3d$ICC[i]
  delta_pp <- results_3d$effect_size_pp[i]
  
  p_I <- p_C + (delta_pp / 100)
  
  if (p_I < 0) {
    next
  }
  
  deff_cv <- 1 + ((m * (1 + CV^2)) - 1) * icc
  
  h <- cohen_h(p_I, p_C)
  
  ss <- pwr.2p.test(h = h, power = power, sig.level = alpha)$n
  
  n_per_arm_crt <- ceiling(ss * deff_cv)
  
  n_clusters_per_arm <- ceiling(n_per_arm_crt / m)
  
  results_3d$n_clusters_per_arm[i] <- n_clusters_per_arm
}
```

```{r}
#| warning: false
#| fig-width: 10
#| fig-height: 7
ggplot(results_3d, aes(x = effect_size_pp, y = ICC, fill = n_clusters_per_arm)) +
  geom_tile() +
  geom_text(aes(label = n_clusters_per_arm), size = 2.5, color = "black") +
  scale_fill_gradient2(
    low = "darkgreen", 
    mid = "yellow", 
    high = "darkred",
    midpoint = median(results_3d$n_clusters_per_arm, na.rm = TRUE),
    name = "Clusters\nper arm"
  ) +
  labs(
    title = "Total POP: Clusters per arm: ICC vs Effect size",
    x = "Effect size (percentage point increase)",
    y = "ICC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) +
  scale_x_continuous(breaks = seq(10, 20, by = 1)) +
  scale_y_continuous(breaks = seq(0.05, 0.30, by = 0.01))
```

### **(1.3.2) Varying CV and varying ICC - overall population**

3-D plot, varying the CV (0.5 to 1.2) & varying ICC (0.05 to 0.2)

Keep the baseline prescription rate at 22% (control rate) and delta at 15 pp

Keep m (cluster size) at 33

```{r}
# Define parameters
power <- 0.80
alpha <- 0.05
p_C <- 0.22
delta_pp <- 15
m <- 33

# Ranges
ICC_values <- seq(0.05, 0.20, by = 0.01)
CV_values <- seq(0.5, 1.2, by = 0.05)

# Create grid
results_3d <- expand.grid(
  ICC = ICC_values,
  CV = CV_values
)

results_3d$n_clusters_per_arm <- NA

cohen_h <- function(p1, p2) {
  2 * (asin(sqrt(p1)) - asin(sqrt(p2)))
}

for (i in 1:nrow(results_3d)) {
  icc <- results_3d$ICC[i]
  cv <- results_3d$CV[i]
  
  p_I <- p_C + (delta_pp / 100)
  
  deff_cv <- 1 + ((m * (1 + cv^2)) - 1) * icc
  
  h <- cohen_h(p_I, p_C)
  
  ss <- pwr.2p.test(h = h, power = power, sig.level = alpha)$n
  
  n_per_arm_crt <- ceiling(ss * deff_cv)
  n_clusters_per_arm <- ceiling(n_per_arm_crt / m)
  
  results_3d$n_clusters_per_arm[i] <- n_clusters_per_arm
}
```

```{r}
#| warning: false
#| fig-width: 10
#| fig-height: 7

ggplot(results_3d, aes(x = CV, y = ICC, fill = n_clusters_per_arm)) +
  geom_tile() +
  geom_text(aes(label = n_clusters_per_arm), size = 2.5, color = "black") +
  scale_fill_gradient2(
    low = "darkgreen",
    mid = "yellow",
    high = "darkred",
    midpoint = median(results_3d$n_clusters_per_arm, na.rm = TRUE),
    name = "Clusters\nper arm"
  ) +
  labs(
    title = "Clusters per arm: ICC vs CV (Effect size = 15pp)",
    x = "Coefficient of Variation (CV)",
    y = "ICC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) +
  scale_x_continuous(breaks = seq(0.5, 1.2, by = 0.05)) +
  scale_y_continuous(breaks = seq(0.05, 0.20, by = 0.01))
```

# **(2) Sample size calculation CRT: Simulation-based**

# **(3) Simulate the full dataset and implement the main analysis strategy**

# **(4) Stratified randomization algorithm**

## **(4.1) Covariate-constrained randomization**

If we use batch-randomization (all clusters randomized at once and no new clusters entering later), the probably simple covariate-constrained randomization to be used: <https://rethinkingclinicaltrials.org/chapters/design/experimental-designs-and-randomization-schemes/covariate-constrained-randomization/>

-   Exact 1:1 overall allocation:

    -   XX Control / XX Intervention

-   Soft site stratification:

    -   Each site gets roughly half clusters in each arm

    -   Small deviations allowed for odd-sized sites

-   Global numeric balance re baseline outcome rate:

    -   Optimises baseline_rate mean difference between arms

-   Random selection among best allocations:

    -   Preserves randomness while enforcing optimal balance

```{r}
set.seed(20250820)

n_clusters <- 84
site <- factor(sample(
  1:7, n_clusters, replace = TRUE,
  prob = c(0.05, 0.15, 0.20, 0.10, 0.15, 0.25, 0.10)
))

cluster_data <- data.frame(
  cluster_id = 1:n_clusters,
  baseline_rate = runif(n_clusters, 0.10, 0.30),
  site = site
)

treatments <- c("Control", "Intervention")

### CCR function for global randomisation
run_global_ccr <- function(df, n_sims = 10000, top_pct = 0.10) {
  n <- nrow(df)
  n_ctrl <- n_int <- n / 2  # exact 1:1 allocation
  
  scores <- numeric(n_sims)
  allocs <- matrix(NA, nrow = n_sims, ncol = n)
  
  for (i in 1:n_sims) {
    # Random 1:1 allocation
    arm_assign <- sample(c(rep("Control", n_ctrl),
                           rep("Intervention", n_int)))
    allocs[i, ] <- arm_assign
    temp <- df
    temp$arm <- arm_assign
    
    # Numeric covariate imbalance
    means_diff <- abs(tapply(temp$baseline_rate, temp$arm, mean)["Control"] -
                      tapply(temp$baseline_rate, temp$arm, mean)["Intervention"])
    
    # Soft site stratification: imbalance = sum of squared differences between observed vs ideal allocation per site
    site_table <- table(temp$site, temp$arm)
    ideal_site <- table(temp$site) / 2  # target per arm per site (soft)
    site_diff <- sum((site_table[, "Control"] - ideal_site)^2 +
                     (site_table[, "Intervention"] - ideal_site)^2)
    
    # Total score: numeric imbalance + small weight for site imbalance
    scores[i] <- means_diff + 0.01 * site_diff
  }
  
  # Select best allocations
  threshold <- quantile(scores, top_pct)
  best_idx <- which(scores <= threshold)
  chosen <- sample(best_idx, 1)
  
  df$final_arm <- allocs[chosen, ]
  return(df)
}

### Run it
final_result <- run_global_ccr(cluster_data)
print(final_result)

### Checks
cat("\nOverall treatment counts:\n")
print(table(final_result$final_arm))

cat("\nBalance within each site (aim: approximate 1:1):\n")
print(table(final_result$site, final_result$final_arm))

cat("\nBalance by mean baseline_rate by arm (aim: approximate 1:1):\n")
print(tapply(final_result$baseline_rate, final_result$final_arm, mean))

```
