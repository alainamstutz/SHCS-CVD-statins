---
title: "NUDGE cluster randomized trial"
author: "A.Amstutz"
format:
  html:
    toc: true
    toc-float: true
    toc-depth: 4
    code-fold: true
    keep-md: true
  pdf:
    toc: true
editor: visual
---

# NUDGE SHCS precision CVD/statin CRT

Nudging intervention on the level of SHCS physicians at SHCS sites to promote statin prescription:

-   **Control**: Usual Care

-   **Intervention**: Nudge shared-decision making based on improved CVD risk score

## **Parameters and design considerations**

-   Two-arm parallel-group, 1:1 allocation, superiority, cluster-randomized

-   Cluster eligibility:

    -   SHCS physicians

    -   From xxx sites

-   Individual eligibility:

    -   XXX

-   Primary outcome (binary): “being prescribed a statin at first patient-encounter”

-   Unit of data collection with be the SHCS cohort participants, but level of inference will be the physicians, i.e. cluster-average

-   Baseline primary outcome rate, see calculation below:

    -   ca. 20%

-   Expected delta:

    -   10 pp ?

-   Cluster size (m) of eligible overall participants, see calculation below:

    -   on average 20 eligible participants per physician-cluster

-   CV (coefficient of variation), see calculation below:

    -   0.90

-   ICC for the primary outcome, see calculation below:

    -   0.10

-   Max. ca. ??? eligible clusters, i.e. ??? clusters per arm

-   Min. desired power 80%, two-sided alpha of 0.05

-   1:1 allocation

**Packages & seed**

```{r}
#| message: false
#| warning: false
req_pkgs <- c("pwr",
              "dplyr",
              "tidyr",
              "purrr",
              "ggplot2",
              "here",
              "lme4",
              "performance",
              "gt"
)
install_if_missing <- function(pkgs){
  for(p in pkgs){
    if(!requireNamespace(p, quietly=TRUE)){
      install.packages(p, repos="https://cloud.r-project.org")
    }
    library(p, character.only=TRUE)
  }
}
install_if_missing(req_pkgs)

# set global RNG seed for reproducibility
set.seed(20250809)
```

**Prep Data SHCS**

```{r}
#| message: false
#| warning: false
df_strict <- readRDS(here("01-strict_selection.rds"))
df_liberal <- readRDS(here("01-liberal_selection.rds"))

# Remove any existing grouping
df_strict <- df_strict |> 
  ungroup()
df_liberal <- df_liberal |> 
  ungroup()
```

## **Calculation CV**

```{r}
# # Keep only physicians who have at least seen 10 pat
# df_strict <- df_strict |>
#   filter(n_elig_study >= 10)

# Calculate CV for cluster sizes (=physicians)
# CV = sd(n_elig_study) / mean(n_elig_study)
cv_strict <- df_strict |>
  summarise(
    n_clusters = n(),
    mean_cluster_size = mean(n_elig_study),
    sd_cluster_size = sd(n_elig_study),
    cv = sd_cluster_size / mean_cluster_size
  )

cv_strict |>
  gt() |>
  cols_label(
    n_clusters = "Number of Clusters",
    mean_cluster_size = "Mean Cluster Size",
    sd_cluster_size = "SD Cluster Size",
    cv = "CV"
  ) |>
  fmt_number(
    columns = c(mean_cluster_size, sd_cluster_size, cv),
    decimals = 2
  # ) |>
  # tab_header(
  #   title = "Coefficient of Variation"
  ) |>
  tab_options(
    table.font.size = 14
  )
```

## **Calculation baseline rate and ICC**

```{r}
# Calculate number of eligible patients who received statins
df_strict <- df_strict |>
  mutate(n_elig_received_statin = round(statin_presc_rate * n_elig_study))

# Reconstruct individual patient data (only eligible patients)
individual_data <- df_strict |>
  rowwise() |>
  mutate(
    patient_data = list(
      tibble(
        statin_prescribed = c(
          rep(1, n_elig_received_statin),
          rep(0, n_elig_study - n_elig_received_statin)
        )
      )
    )
  ) |>
  ungroup() |>
  unnest(patient_data) |>
  select(center, physician, statin_prescribed)

# Verify
ind_data <- individual_data |>
  group_by(physician) |>
  summarise(
    n_total = n(),
    n_received_statin = sum(statin_prescribed),
    rate = mean(statin_prescribed)
  )

# baseline rate
baseline_rate <- individual_data |>
  summarise(
    baseline_rate = mean(statin_prescribed)
  )

baseline_rate

# Calculate ICC
model <- glmer(statin_prescribed ~ 1 + (1 | physician), 
               data = individual_data, 
               family = binomial)

icc(model)
```

## **Corresponding individual randomized trial**

Sample size for the individual randomized trial on the same question

```{r}
# Parameters
p_C <- 0.20
p_I <- 0.30
power <- 0.80 
ICC <- 0.10
alpha <- 0.05

# Effect size, standardized as Cohen's h
h_I_C <- ES.h(p1 = p_I, p2 = p_C)
cat("Cohen's h for Intervention vs Control:", round(h_I_C, 3), "\n")

# Sample size pair-wise comparison
ss_I_C <- pwr.2p.test(h = h_I_C, sig.level = alpha, power = power)
n_per_arm <- ceiling(ss_I_C$n)
n_total <- n_per_arm * 2

cat("Sample size per arm:", n_per_arm, "\n")
cat("Total trial sample size (2-arm trial):", n_total)
```

# **(1) Sample size calculation CRT: formula-based**

Add the design effect (DEFF) to the individual RCT sample size. The usual standard DEFF formula:

DEFF = 1+(m−1)ICC , whereby m = cluster size

However, let's not forget the cluster size variation. The usual conservative adjustment of the DEFF with cluster size variation is (e.g. see here: [https://pmc.ncbi.nlm.nih.gov/articles/PMC7394950/#sup1](#0)):

DEFF_cv = 1+((m(1+CV\^2)−1))ICC , whereby CV is the coefficient of variation (ratio of standard deviation of cluster sizes to mean of cluster sizes)

```{r}
# Parameters
p_C <- 0.20
p_I <- 0.30  
power <- 0.80 
ICC <- 0.10
alpha <- 0.05

m <- 20 # average cluster size
CV <- 0.90 # CV

deff <- 1+(m-1)*ICC # standard DEFF
deff_cv <- 1+((m*(1+CV^2))-1)*ICC # DEFF with cluster size variation

# Effect size
h_I_C <- ES.h(p1 = p_I, p2 = p_C)

# sample size for corresponding individual RCT 
ss <- pwr.2p.test(h = h_I_C, power = power, sig.level = alpha)$n

# CRT sample size
ss_crt <- ceiling(ss * deff_cv)
n_clusters <- ceiling(ss_crt / m)
cat("Cluster sample size one arm:", n_clusters, "\n")
# cat("Individual sample size one arm:", ss_crt, "\n")

# Total
tot_clusters <- n_clusters * 2
tot_ind <- ss_crt * 2
cat("Total cluster sample size:", tot_clusters, "\n")
cat("Total individual sample size:", tot_ind, "\n")
```

## **(1.1) Varying assumptions - Standard sample size calculation**

### **(1.1.1) Varying Effect size and varying ICC**

3-D plot, varying the effect size (10 pp to 20 pp) & varying ICC (0.05 to 0.2)

Keep the baseline prescription rate at 20% (control rate)

Keep m (cluster size) at 20

Keep the CV at 0.9

```{r}
# Define parameters
power <- 0.80
alpha <- 0.05
p_C <- 0.20
CV <- 0.9
m <- 20

# Ranges
ICC_values <- seq(0.05, 0.20, by = 0.01)
effect_sizes_pp <- seq(10, 20, by = 1)

# Create grid
results_3d <- expand.grid(
  ICC = ICC_values,
  effect_size_pp = effect_sizes_pp
)

results_3d$n_clusters_per_arm <- NA

cohen_h <- function(p1, p2) {
  2 * (asin(sqrt(p1)) - asin(sqrt(p2)))
}

for (i in 1:nrow(results_3d)) {
  icc <- results_3d$ICC[i]
  delta_pp <- results_3d$effect_size_pp[i]
  
  p_I <- p_C + (delta_pp / 100)
  
  if (p_I < 0) {
    next
  }
  
  deff_cv <- 1 + ((m * (1 + CV^2)) - 1) * icc
  
  h <- cohen_h(p_I, p_C)
  
  ss <- pwr.2p.test(h = h, power = power, sig.level = alpha)$n
  
  n_per_arm_crt <- ceiling(ss * deff_cv)
  
  n_clusters_per_arm <- ceiling(n_per_arm_crt / m)
  
  results_3d$n_clusters_per_arm[i] <- n_clusters_per_arm
}
```

```{r}
#| warning: false
#| fig-width: 10
#| fig-height: 7
ggplot(results_3d, aes(x = effect_size_pp, y = ICC, fill = n_clusters_per_arm)) +
  geom_tile() +
  geom_text(aes(label = n_clusters_per_arm), size = 2.5, color = "black") +
  scale_fill_gradient2(
    low = "darkgreen", 
    mid = "yellow", 
    high = "darkred",
    midpoint = median(results_3d$n_clusters_per_arm, na.rm = TRUE),
    name = "Clusters\nper arm"
  ) +
  labs(
    title = "Clusters per arm: ICC vs Effect size",
    x = "Effect size (percentage point increase)",
    y = "ICC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) +
  scale_x_continuous(breaks = seq(10, 20, by = 1)) +
  scale_y_continuous(breaks = seq(0.05, 0.30, by = 0.01))
```

### **(1.1.2) Varying CV and varying ICC**

3-D plot, varying the CV (0.3 to 1.4) & varying ICC (0.05 to 0.2)

Keep the baseline prescription rate at 20% (control rate) and delta at 10 pp

Keep m (cluster size) at 20

```{r}
# Define parameters
power <- 0.80
alpha <- 0.05
p_C <- 0.20
delta_pp <- 10
m <- 20

# Ranges
ICC_values <- seq(0.05, 0.20, by = 0.01)
CV_values <- seq(0.3, 1.4, by = 0.1)

# Create grid
results_3d <- expand.grid(
  ICC = ICC_values,
  CV = CV_values
)

results_3d$n_clusters_per_arm <- NA

cohen_h <- function(p1, p2) {
  2 * (asin(sqrt(p1)) - asin(sqrt(p2)))
}

for (i in 1:nrow(results_3d)) {
  icc <- results_3d$ICC[i]
  cv <- results_3d$CV[i]
  
  p_I <- p_C + (delta_pp / 100)
  
  deff_cv <- 1 + ((m * (1 + cv^2)) - 1) * icc
  
  h <- cohen_h(p_I, p_C)
  
  ss <- pwr.2p.test(h = h, power = power, sig.level = alpha)$n
  
  n_per_arm_crt <- ceiling(ss * deff_cv)
  n_clusters_per_arm <- ceiling(n_per_arm_crt / m)
  
  results_3d$n_clusters_per_arm[i] <- n_clusters_per_arm
}
```

```{r}
#| warning: false
#| fig-width: 10
#| fig-height: 7

ggplot(results_3d, aes(x = CV, y = ICC, fill = n_clusters_per_arm)) +
  geom_tile() +
  geom_text(aes(label = n_clusters_per_arm), size = 2.5, color = "black") +
  scale_fill_gradient2(
    low = "darkgreen",
    mid = "yellow",
    high = "darkred",
    midpoint = median(results_3d$n_clusters_per_arm, na.rm = TRUE),
    name = "Clusters\nper arm"
  ) +
  labs(
    title = "Clusters per arm: ICC vs CV (Effect size = 10pp)",
    x = "Coefficient of Variation (CV)",
    y = "ICC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) +
  scale_x_continuous(breaks = seq(0.3, 1.4, by = 0.1)) +
  scale_y_continuous(breaks = seq(0.05, 0.20, by = 0.01))
```

# **(2) Sample size calculation CRT: Simulation-based**

# **(3) Simulate the full dataset and implement the main analysis strategy**

# **(4) Stratified randomization algorithm**

## **(4.1) Covariate-constrained randomization**

If we use batch-randomization (all clusters randomized at once and no new clusters entering later), the probably simple covariate-constrained randomization to be used: <https://rethinkingclinicaltrials.org/chapters/design/experimental-designs-and-randomization-schemes/covariate-constrained-randomization/>

-   Exact 1:1 overall allocation:

    -   XX Control / XX Intervention

-   Soft site stratification:

    -   Each site gets roughly half clusters in each arm

    -   Small deviations allowed for odd-sized sites

-   Global numeric balance re baseline outcome rate:

    -   Optimises baseline_rate mean difference between arms

-   Random selection among best allocations:

    -   Preserves randomness while enforcing optimal balance

```{r}
set.seed(20250820)

n_clusters <- 84
site <- factor(sample(
  1:7, n_clusters, replace = TRUE,
  prob = c(0.05, 0.15, 0.20, 0.10, 0.15, 0.25, 0.10)
))

cluster_data <- data.frame(
  cluster_id = 1:n_clusters,
  baseline_rate = runif(n_clusters, 0.10, 0.30),
  site = site
)

treatments <- c("Control", "Intervention")

### CCR function for global randomisation
run_global_ccr <- function(df, n_sims = 10000, top_pct = 0.10) {
  n <- nrow(df)
  n_ctrl <- n_int <- n / 2  # exact 1:1 allocation
  
  scores <- numeric(n_sims)
  allocs <- matrix(NA, nrow = n_sims, ncol = n)
  
  for (i in 1:n_sims) {
    # Random 1:1 allocation
    arm_assign <- sample(c(rep("Control", n_ctrl),
                           rep("Intervention", n_int)))
    allocs[i, ] <- arm_assign
    temp <- df
    temp$arm <- arm_assign
    
    # Numeric covariate imbalance
    means_diff <- abs(tapply(temp$baseline_rate, temp$arm, mean)["Control"] -
                      tapply(temp$baseline_rate, temp$arm, mean)["Intervention"])
    
    # Soft site stratification: imbalance = sum of squared differences between observed vs ideal allocation per site
    site_table <- table(temp$site, temp$arm)
    ideal_site <- table(temp$site) / 2  # target per arm per site (soft)
    site_diff <- sum((site_table[, "Control"] - ideal_site)^2 +
                     (site_table[, "Intervention"] - ideal_site)^2)
    
    # Total score: numeric imbalance + small weight for site imbalance
    scores[i] <- means_diff + 0.01 * site_diff
  }
  
  # Select best allocations
  threshold <- quantile(scores, top_pct)
  best_idx <- which(scores <= threshold)
  chosen <- sample(best_idx, 1)
  
  df$final_arm <- allocs[chosen, ]
  return(df)
}

### Run it
final_result <- run_global_ccr(cluster_data)
print(final_result)

### Checks
cat("\nOverall treatment counts:\n")
print(table(final_result$final_arm))

cat("\nBalance within each site (aim: approximate 1:1):\n")
print(table(final_result$site, final_result$final_arm))

cat("\nBalance by mean baseline_rate by arm (aim: approximate 1:1):\n")
print(tapply(final_result$baseline_rate, final_result$final_arm, mean))

```
